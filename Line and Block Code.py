# -*- coding: utf-8 -*-
"""Line_Coding_And_Block_Coding.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PEufwfnlaZNpJtfc_we7Ta-I16X3um2x
"""

import numpy as np
import matplotlib.pyplot as plt
import math

"""###References
1. [Line-coding-technique](https://www.mathworks.com/matlabcentral/fileexchange/41995-line-coding-techniques)
2. [Line-coding-matlab](https://manikarea.home.blog/2019/09/13/unipolar-line-coding-with-matlab-source-code-for-encoding-and-decoding/)
3. [Block-coding-technique](https://datacommandnet.blogspot.com/p/block-coding.html)

#**Line Coding**

###**Line Coding Encoding - Unipolar - Non Return to Zero(NRZ)**
"""

bits = np.array([1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1]) 
Time = 10e-6   
bit_rate = 1/Time  
Fs = 4*bit_rate    
N = len(bits)   
T = np.linspace(0,Time,100)

x = np.array([])
for i in range(N):
  temp = bits[i]* np.ones(len(T))
  x = np.append(x, temp)
t = np.linspace(0,N*Time,len(x))

plt.plot(t, x)
plt.show()

"""###**Line Coding Decoding - Unipolar - Non Return to Zero(NRZ)**"""

result = []
counter = 0
for i in range(len(t)):
  if t[i]*bit_rate > counter:
    counter = counter + 1
    result.append(int(x[i]))

print(result)

"""#**Block Coding**

###**Block Coding($mB/nB$ Coding)**
>block coding changes a block of $m$ bits into a block of $n$ bits, where $n$ is larger than $m$. ($n > m$).

>> Block Coding 
>>>$mB/nB$ coding
>>>>It replaces each $m-bit$ group with an $n-bit$ group.


**Steps:**
1. Division: a sequence of bits is divided into groups of $m$ bits. For example, in $4B/5B$ encoding, the original bit sequence is divided into $4-bit$ groups.

2. Substitution: Substitute an $m-bit$ group for an $n-bit$ group. For example, in $4B/5B$ encoding we substitute a $4-bit$ code for a $5-bit$ group.

3. Combination: The $n-bit$ groups are combined together to form a new stream of bits. The new stream has more bits than the original bits.

$Example(4B/5B):$<br/>
Input bits = $[1, 0, 0, 1, 0, 1, 0, 1]$<br/>
Division   = $[1, 0, 0, 1],[0, 1, 0, 1]$<br/>
Substitution = $[1, 0, 0, 1, 1],[0, 1, 0, 1, 1]$<br/>
Combination = $[1, 0, 0, 1, 1, 0, 1, 0, 1, 1]$<br/>
Output bits = $[1, 0, 0, 1, 1, 0, 1, 0, 1, 1]$<br/>

####**Block coding $4B/5B$ with $NRZ-I$ line coding scheme**

**5 Major Steps:**
1. $4B/5B$ encoding
2. $NRZ-I$ encoding
3. Digital Signal
4. $NRZ-I$ decoding
5. $4B/5B$ decoding

**Mapping Codes**
"""

mB = 4
nB = 5
block_coding_mapping_codes = {
# encoding map
"0000": "11110",
"0001": "01001",
"0010": "10100",
"0011": "10101",
"0100": "01010",
"0101": "01011",
"0110": "01110",
"0111": "01111",
"1000": "10010",
"1001": "10011",
"1010": "10110",
"1011": "10111",
"1100": "11010",
"1101": "11011",
"1110": "11100",
"1111": "11101",
# decoding map
"11110": "0000",
"01001": "0001",
"10100": "0010",
"10101": "0011",
"01010": "0100",
"01011": "0101",
"01110": "0110",
"01111": "0111",
"10010": "1000",
"10011": "1001",
"10110": "1010",
"10111": "1011",
"11010": "1100",
"11011": "1101",
"11100": "1110",
"11101": "1111",

}

def get_Mapping_Codes(bits):
  return block_coding_mapping_codes["".join(map(str, bits))]
  
'''
bits = sequence of bits to encoded using mB/nB
'''
def get_MB_NB_Encoding(bits, mB, nB): 
  if len(bits) % mB != 0:
    extra_len = (((len(bits)// mB) + 1) * mB) - len(bits)
    extra = np.array(np.zeros(extra_len), dtype=int)
    bits = np.append(bits, extra)
  
  encoded_bits_str = ""
  for i in range(0, len(bits), mB):
    encoded_bits_str += get_Mapping_Codes(bits[i:i+mB])
  
  encoded_bits_list = list(encoded_bits_str)
  encoded_bits_map = map(int, encoded_bits_list)
  encoded_bits = np.array(list(encoded_bits_map))
  return encoded_bits


def get_NB_MB_Decoding(bits, mB, nB):
  if len(bits) % nB != 0:
    print("Length not Valid")
    return
  decoded_bits_str = ""
  for i in range(0, len(bits), nB):
    decoded_bits_str += get_Mapping_Codes(bits[i:i+nB])
  decoded_bits_list = list(decoded_bits_str)
  decoded_bits_map = map(int, decoded_bits_list)
  decoded_bits = np.array(list(decoded_bits_map))
  return decoded_bits

"""**$4B/5B$ Encoding**"""

bits = np.array([1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1], dtype=int) 
bits = get_MB_NB_Encoding(bits, mB, nB)

"""**$NRZ-I$ Line Coding Encoding**"""

Time = 10e-6   
bit_rate = 1/Time  
Fs = 4*bit_rate    
N = len(bits)   
T = np.linspace(0,Time, mB * 100)

x = np.array([])
last_bit = 1
for i in range(N):
  if bits[i] == 1:
    temp = (-1) * last_bit * np.ones(len(T))
    last_bit = -last_bit
  else:
    temp = last_bit * np.ones(len(T))
  x = np.append(x, temp)
t = np.linspace(0,N*Time,len(x))

plt.plot(t, x)
plt.show()

"""**$NRZ-I$ Line Coding Decoding**"""

result = []
counter = 0
last_bit = 1
for i in range(len(t)):
  if t[i]*bit_rate > counter:
    counter = counter + 1
    if x[i] != last_bit:
      result.append(1)
      last_bit=-last_bit
    else:
      result.append(0)

print(result)

"""**$4B/5B$ Decoding**"""

decoded_result = get_NB_MB_Decoding(result, mB, nB)
print(decoded_result)