# -*- coding: utf-8 -*-
"""Pulse_Code_Modulation(PCM).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19mnpS_nZp7b6sg1_rojt9VgnFbAd1q0O

**A program to simulate the analog-digital signal using Pulse Code Modulation.**

*The most common technique to change an analog signal to digital data (digitization) is called **pulse code modulation (PCM)**. A PCM encoder has three processes:*


1. The analog signal is sampled.
2. The sampled signal is quantized.
3. The quantized values are encoded as streams of bits.

*References:*

1. [Analog-to-Digital](https://courses.engr.illinois.edu/ece110/sp2021/content/courseNotes/files/?samplingAndQuantization)
"""

import numpy as np
import matplotlib.pyplot as plt
import math

"""**The signal we're going to work with has following equation:**

$$ v(t)=Acos(2πft) $$
"""

A = 8                           
f = 2
T = 1 / f
t = np.linspace(0, 2.0, 120)
x = A * np.cos(2.0 * np.pi * f * t)
plt.plot(t, x)
plt.show()

"""**>>>>> Process 1 - Sampling**

> Recording an analog signal at evenly spaced instants in time creates samples.

Say, the signal $v(t)=cos(2πft)$ is sampled uniformly with n sampling intervals within each signal period T.

>> Sampling is the process of recording an analog signal at regular discrete moments of time.The sampling rate $fs$ is the number of samples per second. The time interval between samples is called the sampling interval $Ts=1/fs$. 

>>If a signal $v(t)=cos(2πft)$ is uniormly sampled at $n$ (number of sample per interval) over a time period $T$, then the sampling interval $Ts=T/n$ and the sampling rate $fs=nf$. 
$$Ts = T/n = 1/nf$$
$$Ts = 1/fs$$
$$fs = nf$$

>> The sampled signal of the analog signal $v(t)$ is expressed by $v[n]$, where $n$ is the index of the samples.

>> When $n=0$ sample is taken from the $t=0$ time point of the analog signal
>> When $n=1$ sample must come from the $t=Ts$ time point, because $Ts$ is the sampling interval.

>> So, the sequence of samples can be written as $v[0]=v(0)$, $v[1]=v(Ts)$, $v[2]=v(2Ts)$, and so on.<br/>


So,
$$v[n]=v(nTs)$$



"""

n = 18
fs = n * f
ts=np.arange(0, 2, 1 / fs)
xs=A*np.cos(2*np.pi*f*ts);
# xs Sampled signal 
plt.stem(ts, xs)
plt.show()

"""**>>>>> Process 2 - Quantization**

> Quantizing samples to levels and then to sequences of bits leads to quantization error.

>> The result of sampling is a series of pulses with amplitude values between the maximum and minimum amplitudes of the signal. Because of the sampled values can potentially take on a continuous range of values, these values cannot be used in the encoding
process.

>>In analog to digital conversion, each sample value is mapped to a discrete level (represented by a sequence of bits). This is known as the **Quantization** process.

>> In a $B-bit$ quantizer, each quantization level is represented with $B$ bits, so that the number of levels equals $L = 2^B$

*The following are the steps in quantization:*
1. We assume that the original analog signal has instantaneous amplitudes between $Vmin$ and $Vmax$
2. We divide the amplitude range into L zones, each of height $\Delta$ (delta).
$$\Delta = \frac{Vmax - Vmin}{L}$$
3. We assign quantized values of 0 to $L - 1$ to the midpoint of each level zone.
4. We approximate the value of the sample amplitude to the quantized values.

>> If we decide to have eight levels (b-bit = 3, L = 8, height = $\Delta$), then our partitioned amplitude will be from $-4\Delta$ to $4\Delta$.

>>As the quantized value is the midpoint of each level zone, 
* the value between $4\Delta$ and $3\Delta$ will be quantized into their midpoint, $3\Delta$+${\Delta/2}$, also assigned the encode value 7.
* the value between $3\Delta$ and $3\Delta$ will be quantized into their midpoint, $2\Delta$+${\Delta/2}$, also assigned the encode value 6. and so on...



| Quantized codec | Normalized Amplitude| Quantized value       |
|-----------------|---------------------|-----------------------|
|                 |       $4\Delta$     |                       | 
|       7         |                     | $3\Delta$+${\Delta/2}$|
|                 |       $3\Delta$     |
|       6         |                     | $2\Delta$+${\Delta/2}$|
|                 |       $2\Delta$     |
|       5         |                     | $\Delta$+${\Delta/2}$ |
|                 |        $\Delta$     |
|       4         |                     |      ${\Delta/2}$     |
|                 |       0             |
|       3         |                     | $-\Delta$+${\Delta/2}$|
|                 |       $-\Delta$     |
|       2         |                     |$-2\Delta$+${\Delta/2}$|
|                 |       $-2\Delta$    |
|       1         |                     |$-3\Delta$+${\Delta/2}$|
|                 |       $-3\Delta$    |
|       0         |                     |$-4\Delta$+${\Delta/2}$|
|                 |       $-4\Delta$    |
|-----------------|---------------------|-----------------------|

###To find midpoint of each level zone(for assigning these midpoint as quantized value):
1. Partition/divide the amplitude range with height $\Delta$
2. Decrease each of the parition value by ${\Delta/2}$ (called codebook)
3. Assign the numbers in each interval of the codebook to the corresponding partition number(quantized value). 
4. To make quantize value inbetween the levels, increased each quantized value by ${\Delta/2}$


"""

b_bit = 3
L = 2 ** b_bit
vmax=A;
vmin=-vmax;
delta=(vmax-vmin)/L;
partition = np.arange(vmin, vmax, delta)
codebook= np.arange(vmin-(delta/2),vmax+(delta/2), delta) 

xq = np.copy(xs)
encode = np.copy(xs)

for i in range(len(partition)):
  left = codebook[i]
  right = codebook[i + 1]
  for j in range(len(xs)):
    if(i != len(partition) - 1 and left <= xs[j] and xs[j] < right):
      xq[j] = partition[i]
      encode[j] = i
    if(i == len(partition) - 1 and left <= xs[j]):
      xq[j] = partition[i]
      encode[j] = i

for i in range(len(xq)):
    xq[i] = xq[i] + (delta / 2) 

plt.stem(ts, xq)
plt.show()

"""**>>>>> Process 3 - Encoding**

1. Convert the assigned decimal codec to the binary codec
2. Append all the binary codec into an array of 0 and 1.
3. plot a step graph
"""

def decimalToBinary(val, bit):
    binary = "{0:b}".format(int(val))
    if(len(binary) > bit):
      return binary
    extra_zero = bit - len(binary)
    return extra_zero * "0" + binary

binary_codec = []
for i in range(len(encode)):
  binary = decimalToBinary(encode[i], b_bit)
  for j in range(len(binary)):
    binary_codec.append(binary[j])

pos = np.arange(len(binary_codec))
plt.figure(figsize=(20, 5))
plt.ylim(-1, 2)
plt.step(pos, binary_codec)
plt.show()

"""**Thanks**"""